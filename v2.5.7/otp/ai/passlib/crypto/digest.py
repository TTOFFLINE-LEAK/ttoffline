from __future__ import division
import hashlib, logging
log = logging.getLogger(__name__)
try:
    from hashlib import pbkdf2_hmac as _stdlib_pbkdf2_hmac
    if _stdlib_pbkdf2_hmac.__module__ == 'hashlib':
        log.debug('ignoring pure-python hashlib.pbkdf2_hmac()')
        _stdlib_pbkdf2_hmac = None
except ImportError:
    _stdlib_pbkdf2_hmac = None
else:
    import re, os
    from struct import Struct
    from warnings import warn
    try:
        from fastpbkdf2 import pbkdf2_hmac as _fast_pbkdf2_hmac
    except ImportError:
        _fast_pbkdf2_hmac = None

from otp.ai.passlib import exc
from otp.ai.passlib.utils import join_bytes, to_native_str, join_byte_values, to_bytes, SequenceMixin
from otp.ai.passlib.utils.compat import irange, int_types, unicode_or_bytes_types, PY3
from otp.ai.passlib.utils.decor import memoized_property
__all__ = [
 'lookup_hash',
 'HashInfo',
 'norm_hash_name',
 'compile_hmac',
 'pbkdf1',
 'pbkdf2_hmac']
MAX_UINT32 = 4294967295L
MAX_UINT64 = 18446744073709551615L
_known_hash_names = [
 ('md2', 'md2'),
 ('md5', 'md5'),
 ('sha1', 'sha-1'),
 ('sha224', 'sha-224', 'sha2-224'),
 ('sha256', 'sha-256', 'sha2-256'),
 ('sha384', 'sha-384', 'sha2-384'),
 ('sha512', 'sha-512', 'sha2-512'),
 ('md4', 'md4'),
 ('sha', 'sha-0', 'sha0'),
 ('ripemd', 'ripemd'),
 ('ripemd160', 'ripemd-160')]
_hash_info_cache = {}

def _get_hash_aliases(name):
    orig = name
    if not isinstance(name, str):
        name = to_native_str(name, 'utf-8', 'hash name')
    name = re.sub('[_ /]', '-', name.strip().lower())
    if name.startswith('scram-'):
        name = name[6:]
        if name.endswith('-plus'):
            name = name[:-5]

    def check_table(name):
        for row in _known_hash_names:
            if name in row:
                return row

    result = check_table(name)
    if result:
        return result
    m = re.match('(?i)^(?P<name>[a-z]+)-?(?P<rev>\\d)?-?(?P<size>\\d{3,4})?$', name)
    if m:
        iana_name, rev, size = m.group('name', 'rev', 'size')
        if rev:
            iana_name += rev
        hashlib_name = iana_name
        if size:
            iana_name += '-' + size
            if rev:
                hashlib_name += '_'
            hashlib_name += size
        result = check_table(iana_name)
        if result:
            return result
        log.info('normalizing unrecognized hash name %r => %r / %r', orig, hashlib_name, iana_name)
    else:
        iana_name = name
        hashlib_name = name.replace('-', '_')
        log.warning('normalizing unrecognized hash name and format %r => %r / %r', orig, hashlib_name, iana_name)
    return (
     hashlib_name, iana_name)


def _get_hash_const(name):
    if not name.startswith('_') and name not in ('new', 'algorithms'):
        try:
            return getattr(hashlib, name)
        except AttributeError:
            pass

    new_ssl_hash = hashlib.new
    try:
        new_ssl_hash(name, '')
    except ValueError:
        pass
    else:

        def const(msg=''):
            return new_ssl_hash(name, msg)

        const.__name__ = name
        const.__module__ = 'hashlib'
        const.__doc__ = 'wrapper for hashlib.new(%r),\ngenerated by passlib.crypto.digest.lookup_hash()' % name
        return const

    if name == 'md4':
        from otp.ai.passlib.crypto._md4 import md4
        return md4
    return


def lookup_hash(digest, return_unknown=False):
    cache = _hash_info_cache
    try:
        return cache[digest]
    except (KeyError, TypeError):
        pass
    else:
        cache_by_name = True
        if isinstance(digest, unicode_or_bytes_types):
            name_list = _get_hash_aliases(digest)
            name = name_list[0]
            if name != digest:
                info = lookup_hash(name, return_unknown=return_unknown)
                if info.const is None:
                    return info
                cache[digest] = info
                return info
            const = _get_hash_const(name)
            if const is None:
                if return_unknown:
                    return HashInfo(None, name_list)
                raise exc.UnknownHashError(name)
        else:
            if isinstance(digest, HashInfo):
                return digest
        if callable(digest):
            const = digest
            name_list = _get_hash_aliases(const().name)
            name = name_list[0]
            other_const = _get_hash_const(name)
            if other_const is None:
                pass
            elif other_const is const:
                pass
            else:
                cache_by_name = False
        else:
            raise exc.ExpectedTypeError(digest, 'digest name or constructor', 'digest')

    info = HashInfo(const, name_list)
    cache[const] = info
    if cache_by_name:
        for name in name_list:
            if name:
                cache[name] = info

    return info


lookup_hash.clear_cache = _hash_info_cache.clear

def norm_hash_name(name, format='hashlib'):
    info = lookup_hash(name, return_unknown=True)
    if not info.const:
        warn('norm_hash_name(): unknown hash: %r' % (name,), exc.PasslibRuntimeWarning)
    if format == 'hashlib':
        return info.name
    if format == 'iana':
        return info.iana_name
    raise ValueError('unknown format: %r' % (format,))


class HashInfo(SequenceMixin):
    name = None
    iana_name = None
    aliases = ()
    const = None
    digest_size = None
    block_size = None

    def __init__(self, const, names):
        self.name = names[0]
        self.iana_name = names[1]
        self.aliases = names[2:]
        self.const = const
        if const is None:
            return
        hash = const()
        self.digest_size = hash.digest_size
        self.block_size = hash.block_size
        if len(hash.digest()) != hash.digest_size:
            raise RuntimeError('%r constructor failed sanity check' % self.name)
        if hash.name != self.name:
            warn('inconsistent digest name: %r resolved to %r, which reports name as %r' % (
             self.name, const, hash.name), exc.PasslibRuntimeWarning)
        return

    def __repr__(self):
        return '<lookup_hash(%r): digest_size=%r block_size=%r)' % (
         self.name, self.digest_size, self.block_size)

    def _as_tuple(self):
        return (
         self.const, self.digest_size, self.block_size)

    @memoized_property
    def supported_by_fastpbkdf2(self):
        if not _fast_pbkdf2_hmac:
            return
        try:
            _fast_pbkdf2_hmac(self.name, 'p', 's', 1)
            return True
        except ValueError:
            return False

        return

    @memoized_property
    def supported_by_hashlib_pbkdf2(self):
        if not _stdlib_pbkdf2_hmac:
            return
        try:
            _stdlib_pbkdf2_hmac(self.name, 'p', 's', 1)
            return True
        except ValueError:
            return False

        return


_TRANS_5C = join_byte_values(x ^ 92 for x in irange(256))
_TRANS_36 = join_byte_values(x ^ 54 for x in irange(256))

def compile_hmac(digest, key, multipart=False):
    digest_info = lookup_hash(digest)
    const, digest_size, block_size = digest_info
    if not isinstance(key, bytes):
        key = to_bytes(key, param='key')
    klen = len(key)
    if klen > block_size:
        key = const(key).digest()
        klen = digest_size
    if klen < block_size:
        key += '\x00' * (block_size - klen)
    _inner_copy = const(key.translate(_TRANS_36)).copy
    _outer_copy = const(key.translate(_TRANS_5C)).copy
    if multipart:

        def hmac():
            inner = _inner_copy()

            def finalize():
                outer = _outer_copy()
                outer.update(inner.digest())
                return outer.digest()

            return (
             inner.update, finalize)

    else:

        def hmac(msg):
            inner = _inner_copy()
            inner.update(msg)
            outer = _outer_copy()
            outer.update(inner.digest())
            return outer.digest()

    hmac.digest_info = digest_info
    return hmac


def pbkdf1(digest, secret, salt, rounds, keylen=None):
    const, digest_size, block_size = lookup_hash(digest)
    secret = to_bytes(secret, param='secret')
    salt = to_bytes(salt, param='salt')
    if not isinstance(rounds, int_types):
        raise exc.ExpectedTypeError(rounds, 'int', 'rounds')
    if rounds < 1:
        raise ValueError('rounds must be at least 1')
    if keylen is None:
        keylen = digest_size
    else:
        if not isinstance(keylen, int_types):
            raise exc.ExpectedTypeError(keylen, 'int or None', 'keylen')
        else:
            if keylen < 0:
                raise ValueError('keylen must be at least 0')
            else:
                if keylen > digest_size:
                    raise ValueError('keylength too large for digest: %r > %r' % (
                     keylen, digest_size))
    block = secret + salt
    for _ in irange(rounds):
        block = const(block).digest()

    return block[:keylen]


_pack_uint32 = Struct('>L').pack

def pbkdf2_hmac(digest, secret, salt, rounds, keylen=None):
    secret = to_bytes(secret, param='secret')
    salt = to_bytes(salt, param='salt')
    digest_info = lookup_hash(digest)
    digest_size = digest_info.digest_size
    if not isinstance(rounds, int_types):
        raise exc.ExpectedTypeError(rounds, 'int', 'rounds')
    if rounds < 1:
        raise ValueError('rounds must be at least 1')
    if keylen is None:
        keylen = digest_size
    else:
        if not isinstance(keylen, int_types):
            raise exc.ExpectedTypeError(keylen, 'int or None', 'keylen')
        else:
            if keylen < 1:
                raise ValueError('keylen must be at least 1')
            block_count = (keylen + digest_size - 1) // digest_size
            if block_count > MAX_UINT32:
                raise OverflowError('keylen too long for digest')
            if digest_info.supported_by_fastpbkdf2:
                return _fast_pbkdf2_hmac(digest_info.name, secret, salt, rounds, keylen)
        if digest_info.supported_by_hashlib_pbkdf2:
            return _stdlib_pbkdf2_hmac(digest_info.name, secret, salt, rounds, keylen)
    keyed_hmac = compile_hmac(digest, secret)
    calc_block = _get_pbkdf2_looper(digest_size)
    return join_bytes(calc_block(keyed_hmac, keyed_hmac(salt + _pack_uint32(i)), rounds) for i in irange(1, block_count + 1))[:keylen]


_force_backend = 'hexlify'
if PY3 and _force_backend in ('any', 'from-bytes'):
    from functools import partial

    def _get_pbkdf2_looper(digest_size):
        return partial(_pbkdf2_looper, digest_size)


    def _pbkdf2_looper(digest_size, keyed_hmac, digest, rounds):
        from_bytes = int.from_bytes
        BIG = 'big'
        accum = from_bytes(digest, BIG)
        for _ in irange(rounds - 1):
            digest = keyed_hmac(digest)
            accum ^= from_bytes(digest, BIG)

        return accum.to_bytes(digest_size, BIG)


    _builtin_backend = 'from-bytes'
else:
    if _force_backend in ('any', 'unpack', 'from-bytes'):
        from struct import Struct
        from otp.ai.passlib.utils import sys_bits
        _have_64_bit = sys_bits >= 64
        _looper_cache = {}

        def _get_pbkdf2_looper(digest_size):
            try:
                return _looper_cache[digest_size]
            except KeyError:
                pass

            if _have_64_bit and not digest_size & 7:
                count = digest_size >> 3
                fmt = '=%dQ' % count
            else:
                if not digest_size & 3:
                    if _have_64_bit:
                        count = digest_size >> 3
                        fmt = '=%dQI' % count
                        count += 1
                    else:
                        count = digest_size >> 2
                        fmt = '=%dI' % count
                else:
                    raise NotImplementedError('unsupported digest size: %d' % digest_size)
            struct = Struct(fmt)
            tdict = dict(digest_size=digest_size, accum_vars=(', ').join('acc_%d' % i for i in irange(count)), digest_vars=(', ').join('dig_%d' % i for i in irange(count)))
            source = ("def helper(keyed_hmac, digest, rounds):\n    '''pbkdf2 loop helper for digest_size={digest_size}'''\n    unpack_digest = struct.unpack\n    {accum_vars} = unpack_digest(digest)\n    for _ in irange(1, rounds):\n        digest = keyed_hmac(digest)\n        {digest_vars} = unpack_digest(digest)\n").format(**tdict)
            for i in irange(count):
                source += '        acc_%d ^= dig_%d\n' % (i, i)

            source += ('    return struct.pack({accum_vars})\n').format(**tdict)
            code = compile(source, '<generated by passlib.crypto.digest._get_pbkdf2_looper()>', 'exec')
            gdict = dict(irange=irange, struct=struct)
            ldict = dict()
            eval(code, gdict, ldict)
            helper = ldict['helper']
            _looper_cache[digest_size] = helper
            return helper


        _builtin_backend = 'unpack'
    else:
        from binascii import hexlify as _hexlify
        from otp.ai.passlib.utils import int_to_bytes

        def _get_pbkdf2_looper(digest_size):
            return _pbkdf2_looper


        def _pbkdf2_looper(keyed_hmac, digest, rounds):
            hexlify = _hexlify
            accum = int(hexlify(digest), 16)
            for _ in irange(rounds - 1):
                digest = keyed_hmac(digest)
                accum ^= int(hexlify(digest), 16)

            return int_to_bytes(accum, len(digest))


        _builtin_backend = 'hexlify'
if _force_backend == _builtin_backend:
    _fast_pbkdf2_hmac = _stdlib_pbkdf2_hmac = None
PBKDF2_BACKENDS = [ b for b in [
 'fastpbkdf2' if _fast_pbkdf2_hmac else None,
 'hashlib-ssl' if _stdlib_pbkdf2_hmac else None,
 'builtin-' + _builtin_backend] if b
                  ]
if 'fastpbkdf2' in PBKDF2_BACKENDS:
    PBKDF2_SPEED_FACTOR = 3
else:
    if 'hashlib-ssl' in PBKDF2_BACKENDS:
        PBKDF2_SPEED_FACTOR = 1.4
    else:
        PBKDF2_SPEED_FACTOR = 1