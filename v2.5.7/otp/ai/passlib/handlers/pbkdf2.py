from binascii import hexlify, unhexlify
from base64 import b64encode, b64decode
import logging
log = logging.getLogger(__name__)
from otp.ai.passlib.utils import to_unicode
from otp.ai.passlib.utils.binary import ab64_decode, ab64_encode
from otp.ai.passlib.utils.compat import str_to_bascii, u, uascii_to_str, unicode
from otp.ai.passlib.crypto.digest import pbkdf2_hmac
import otp.ai.passlib.utils.handlers as uh
__all__ = [
 'pbkdf2_sha1',
 'pbkdf2_sha256',
 'pbkdf2_sha512',
 'cta_pbkdf2_sha1',
 'dlitz_pbkdf2_sha1',
 'grub_pbkdf2_sha512']

class Pbkdf2DigestHandler(uh.HasRounds, uh.HasRawSalt, uh.HasRawChecksum, uh.GenericHandler):
    setting_kwds = ('salt', 'salt_size', 'rounds')
    checksum_chars = uh.HASH64_CHARS
    default_salt_size = 16
    max_salt_size = 1024
    default_rounds = None
    min_rounds = 1
    max_rounds = 4294967295L
    rounds_cost = 'linear'
    _digest = None

    @classmethod
    def from_string(cls, hash):
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, handler=cls)
        salt = ab64_decode(salt.encode('ascii'))
        if chk:
            chk = ab64_decode(chk.encode('ascii'))
        return cls(rounds=rounds, salt=salt, checksum=chk)

    def to_string(self):
        salt = ab64_encode(self.salt).decode('ascii')
        chk = ab64_encode(self.checksum).decode('ascii')
        return uh.render_mc3(self.ident, self.rounds, salt, chk)

    def _calc_checksum(self, secret):
        return pbkdf2_hmac(self._digest, secret, self.salt, self.rounds, self.checksum_size)


def create_pbkdf2_hash(hash_name, digest_size, rounds=12000, ident=None, module=__name__):
    name = 'pbkdf2_' + hash_name
    if ident is None:
        ident = u('$pbkdf2-%s$') % (hash_name,)
    base = Pbkdf2DigestHandler
    return type(name, (base,), dict(__module__=module, name=name, ident=ident, _digest=hash_name, default_rounds=rounds, checksum_size=digest_size, encoded_checksum_size=(digest_size * 4 + 2) // 3, __doc__='This class implements a generic ``PBKDF2-HMAC-%(digest)s``-based password hash, and follows the :ref:`password-hash-api`.\n\n    It supports a variable-length salt, and a variable number of rounds.\n\n    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:\n\n    :type salt: bytes\n    :param salt:\n        Optional salt bytes.\n        If specified, the length must be between 0-1024 bytes.\n        If not specified, a %(dsc)d byte salt will be autogenerated (this is recommended).\n\n    :type salt_size: int\n    :param salt_size:\n        Optional number of bytes to use when autogenerating new salts.\n        Defaults to %(dsc)d bytes, but can be any value between 0 and 1024.\n\n    :type rounds: int\n    :param rounds:\n        Optional number of rounds to use.\n        Defaults to %(dr)d, but must be within ``range(1,1<<32)``.\n\n    :type relaxed: bool\n    :param relaxed:\n        By default, providing an invalid value for one of the other\n        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,\n        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`\n        will be issued instead. Correctable errors include ``rounds``\n        that are too small or too large, and ``salt`` strings that are too long.\n\n        .. versionadded:: 1.6\n    ' % dict(digest=hash_name.upper(), dsc=base.default_salt_size, dr=rounds)))


pbkdf2_sha1 = create_pbkdf2_hash('sha1', 20, 131000, ident=u('$pbkdf2$'))
pbkdf2_sha256 = create_pbkdf2_hash('sha256', 32, 29000)
pbkdf2_sha512 = create_pbkdf2_hash('sha512', 64, 25000)
ldap_pbkdf2_sha1 = uh.PrefixWrapper('ldap_pbkdf2_sha1', pbkdf2_sha1, '{PBKDF2}', '$pbkdf2$', ident=True)
ldap_pbkdf2_sha256 = uh.PrefixWrapper('ldap_pbkdf2_sha256', pbkdf2_sha256, '{PBKDF2-SHA256}', '$pbkdf2-sha256$', ident=True)
ldap_pbkdf2_sha512 = uh.PrefixWrapper('ldap_pbkdf2_sha512', pbkdf2_sha512, '{PBKDF2-SHA512}', '$pbkdf2-sha512$', ident=True)
CTA_ALTCHARS = '-_'

class cta_pbkdf2_sha1(uh.HasRounds, uh.HasRawSalt, uh.HasRawChecksum, uh.GenericHandler):
    name = 'cta_pbkdf2_sha1'
    setting_kwds = ('salt', 'salt_size', 'rounds')
    ident = u('$p5k2$')
    checksum_size = 20
    default_salt_size = 16
    max_salt_size = 1024
    default_rounds = pbkdf2_sha1.default_rounds
    min_rounds = 1
    max_rounds = 4294967295L
    rounds_cost = 'linear'

    @classmethod
    def from_string(cls, hash):
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, rounds_base=16, handler=cls)
        salt = b64decode(salt.encode('ascii'), CTA_ALTCHARS)
        if chk:
            chk = b64decode(chk.encode('ascii'), CTA_ALTCHARS)
        return cls(rounds=rounds, salt=salt, checksum=chk)

    def to_string(self):
        salt = b64encode(self.salt, CTA_ALTCHARS).decode('ascii')
        chk = b64encode(self.checksum, CTA_ALTCHARS).decode('ascii')
        return uh.render_mc3(self.ident, self.rounds, salt, chk, rounds_base=16)

    def _calc_checksum(self, secret):
        return pbkdf2_hmac('sha1', secret, self.salt, self.rounds, 20)


class dlitz_pbkdf2_sha1(uh.HasRounds, uh.HasSalt, uh.GenericHandler):
    name = 'dlitz_pbkdf2_sha1'
    setting_kwds = ('salt', 'salt_size', 'rounds')
    ident = u('$p5k2$')
    _stub_checksum = u('0' * 48 + '=')
    default_salt_size = 16
    max_salt_size = 1024
    salt_chars = uh.HASH64_CHARS
    default_rounds = pbkdf2_sha1.default_rounds
    min_rounds = 1
    max_rounds = 4294967295L
    rounds_cost = 'linear'

    @classmethod
    def from_string(cls, hash):
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, rounds_base=16, default_rounds=400, handler=cls)
        return cls(rounds=rounds, salt=salt, checksum=chk)

    def to_string(self):
        rounds = self.rounds
        if rounds == 400:
            rounds = None
        return uh.render_mc3(self.ident, rounds, self.salt, self.checksum, rounds_base=16)

    def _get_config(self):
        rounds = self.rounds
        if rounds == 400:
            rounds = None
        return uh.render_mc3(self.ident, rounds, self.salt, None, rounds_base=16)

    def _calc_checksum(self, secret):
        salt = self._get_config()
        result = pbkdf2_hmac('sha1', secret, salt, self.rounds, 24)
        return ab64_encode(result).decode('ascii')


class atlassian_pbkdf2_sha1(uh.HasRawSalt, uh.HasRawChecksum, uh.GenericHandler):
    name = 'atlassian_pbkdf2_sha1'
    setting_kwds = ('salt', )
    ident = u('{PKCS5S2}')
    checksum_size = 32
    min_salt_size = max_salt_size = 16

    @classmethod
    def from_string(cls, hash):
        hash = to_unicode(hash, 'ascii', 'hash')
        ident = cls.ident
        if not hash.startswith(ident):
            raise uh.exc.InvalidHashError(cls)
        data = b64decode(hash[len(ident):].encode('ascii'))
        salt, chk = data[:16], data[16:]
        return cls(salt=salt, checksum=chk)

    def to_string(self):
        data = self.salt + self.checksum
        hash = self.ident + b64encode(data).decode('ascii')
        return uascii_to_str(hash)

    def _calc_checksum(self, secret):
        return pbkdf2_hmac('sha1', secret, self.salt, 10000, 32)


class grub_pbkdf2_sha512(uh.HasRounds, uh.HasRawSalt, uh.HasRawChecksum, uh.GenericHandler):
    name = 'grub_pbkdf2_sha512'
    setting_kwds = ('salt', 'salt_size', 'rounds')
    ident = u('grub.pbkdf2.sha512.')
    checksum_size = 64
    default_salt_size = 64
    max_salt_size = 1024
    default_rounds = pbkdf2_sha512.default_rounds
    min_rounds = 1
    max_rounds = 4294967295L
    rounds_cost = 'linear'

    @classmethod
    def from_string(cls, hash):
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, sep=u('.'), handler=cls)
        salt = unhexlify(salt.encode('ascii'))
        if chk:
            chk = unhexlify(chk.encode('ascii'))
        return cls(rounds=rounds, salt=salt, checksum=chk)

    def to_string(self):
        salt = hexlify(self.salt).decode('ascii').upper()
        chk = hexlify(self.checksum).decode('ascii').upper()
        return uh.render_mc3(self.ident, self.rounds, salt, chk, sep=u('.'))

    def _calc_checksum(self, secret):
        return pbkdf2_hmac('sha512', secret, self.salt, self.rounds, 64)