from base64 import b64encode
from binascii import hexlify
from hashlib import md5, sha1, sha256
import logging
log = logging.getLogger(__name__)
from otp.ai.passlib.handlers.bcrypt import _wrapped_bcrypt
from otp.ai.passlib.hash import argon2, bcrypt, pbkdf2_sha1, pbkdf2_sha256
from otp.ai.passlib.utils import to_unicode, rng, getrandstr
from otp.ai.passlib.utils.binary import BASE64_CHARS
from otp.ai.passlib.utils.compat import str_to_uascii, uascii_to_str, unicode, u
from otp.ai.passlib.crypto.digest import pbkdf2_hmac
import otp.ai.passlib.utils.handlers as uh
__all__ = [
 'django_salted_sha1',
 'django_salted_md5',
 'django_bcrypt',
 'django_pbkdf2_sha1',
 'django_pbkdf2_sha256',
 'django_argon2',
 'django_des_crypt',
 'django_disabled']
des_crypt = None

def _import_des_crypt():
    global des_crypt
    if des_crypt is None:
        from otp.ai.passlib.hash import des_crypt
    return des_crypt


SALT_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

class DjangoSaltedHash(uh.HasSalt, uh.GenericHandler):
    setting_kwds = ('salt', 'salt_size')
    default_salt_size = 12
    max_salt_size = None
    salt_chars = SALT_CHARS
    checksum_chars = uh.LOWER_HEX_CHARS

    @classmethod
    def from_string(cls, hash):
        salt, chk = uh.parse_mc2(hash, cls.ident, handler=cls)
        return cls(salt=salt, checksum=chk)

    def to_string(self):
        return uh.render_mc2(self.ident, self.salt, self.checksum)


class DjangoVariableHash(uh.HasRounds, DjangoSaltedHash):
    setting_kwds = DjangoSaltedHash.setting_kwds + ('rounds', )
    min_rounds = 1

    @classmethod
    def from_string(cls, hash):
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, handler=cls)
        return cls(rounds=rounds, salt=salt, checksum=chk)

    def to_string(self):
        return uh.render_mc3(self.ident, self.rounds, self.salt, self.checksum)


class django_salted_sha1(DjangoSaltedHash):
    name = 'django_salted_sha1'
    django_name = 'sha1'
    ident = u('sha1$')
    checksum_size = 40

    def _calc_checksum(self, secret):
        if isinstance(secret, unicode):
            secret = secret.encode('utf-8')
        return str_to_uascii(sha1(self.salt.encode('ascii') + secret).hexdigest())


class django_salted_md5(DjangoSaltedHash):
    name = 'django_salted_md5'
    django_name = 'md5'
    ident = u('md5$')
    checksum_size = 32

    def _calc_checksum(self, secret):
        if isinstance(secret, unicode):
            secret = secret.encode('utf-8')
        return str_to_uascii(md5(self.salt.encode('ascii') + secret).hexdigest())


django_bcrypt = uh.PrefixWrapper('django_bcrypt', bcrypt, prefix=u('bcrypt$'), ident=u('bcrypt$'), doc='This class implements Django 1.4\'s BCrypt wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!bcrypt` itself, but with\n    the Django-specific prefix ``"bcrypt$"`` prepended.\n\n    See :doc:`/lib/passlib.hash.bcrypt` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.4\'s :class:`!BCryptPasswordHasher` class.\n\n    .. versionadded:: 1.6\n    ')
django_bcrypt.django_name = 'bcrypt'
django_bcrypt._using_clone_attrs += ('django_name', )

class django_bcrypt_sha256(_wrapped_bcrypt):
    name = 'django_bcrypt_sha256'
    django_name = 'bcrypt_sha256'
    _digest = sha256
    django_prefix = u('bcrypt_sha256$')

    @classmethod
    def identify(cls, hash):
        hash = uh.to_unicode_for_identify(hash)
        if not hash:
            return False
        return hash.startswith(cls.django_prefix)

    @classmethod
    def from_string(cls, hash):
        hash = to_unicode(hash, 'ascii', 'hash')
        if not hash.startswith(cls.django_prefix):
            raise uh.exc.InvalidHashError(cls)
        bhash = hash[len(cls.django_prefix):]
        if not bhash.startswith('$2'):
            raise uh.exc.MalformedHashError(cls)
        return super(django_bcrypt_sha256, cls).from_string(bhash)

    def to_string(self):
        bhash = super(django_bcrypt_sha256, self).to_string()
        return uascii_to_str(self.django_prefix) + bhash

    def _calc_checksum(self, secret):
        if isinstance(secret, unicode):
            secret = secret.encode('utf-8')
        secret = hexlify(self._digest(secret).digest())
        return super(django_bcrypt_sha256, self)._calc_checksum(secret)


class django_pbkdf2_sha256(DjangoVariableHash):
    name = 'django_pbkdf2_sha256'
    django_name = 'pbkdf2_sha256'
    ident = u('pbkdf2_sha256$')
    min_salt_size = 1
    max_rounds = 4294967295L
    checksum_chars = uh.PADDED_BASE64_CHARS
    checksum_size = 44
    default_rounds = pbkdf2_sha256.default_rounds
    _digest = 'sha256'

    def _calc_checksum(self, secret):
        hash = pbkdf2_hmac(self._digest, secret, self.salt, self.rounds)
        return b64encode(hash).rstrip().decode('ascii')


class django_pbkdf2_sha1(django_pbkdf2_sha256):
    name = 'django_pbkdf2_sha1'
    django_name = 'pbkdf2_sha1'
    ident = u('pbkdf2_sha1$')
    checksum_size = 28
    default_rounds = pbkdf2_sha1.default_rounds
    _digest = 'sha1'


django_argon2 = uh.PrefixWrapper('django_argon2', argon2, prefix=u('argon2'), ident=u('argon2$argon2i$'), doc='This class implements Django 1.10\'s Argon2 wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!argon2` itself, but with\n    the Django-specific prefix ``"argon2$"`` prepended.\n\n    See :doc:`argon2 </lib/passlib.hash.argon2>` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.10\'s :class:`!Argon2PasswordHasher` class.\n\n    .. versionadded:: 1.7\n    ')
django_argon2.django_name = 'argon2'
django_argon2._using_clone_attrs += ('django_name', )

class django_des_crypt(uh.TruncateMixin, uh.HasSalt, uh.GenericHandler):
    name = 'django_des_crypt'
    django_name = 'crypt'
    setting_kwds = ('salt', 'salt_size', 'truncate_error')
    ident = u('crypt$')
    checksum_chars = salt_chars = uh.HASH64_CHARS
    checksum_size = 11
    min_salt_size = default_salt_size = 2
    truncate_size = 8
    use_duplicate_salt = True

    @classmethod
    def from_string(cls, hash):
        salt, chk = uh.parse_mc2(hash, cls.ident, handler=cls)
        if chk:
            if not salt:
                salt = chk[:2]
            else:
                if salt[:2] != chk[:2]:
                    raise uh.exc.MalformedHashError(cls, 'first two digits of salt and checksum must match')
            chk = chk[2:]
        return cls(salt=salt, checksum=chk)

    def to_string(self):
        salt = self.salt
        chk = salt[:2] + self.checksum
        if self.use_duplicate_salt:
            return uh.render_mc2(self.ident, salt, chk)
        return uh.render_mc2(self.ident, '', chk)

    def _calc_checksum(self, secret):
        if des_crypt is None:
            _import_des_crypt()
        if self.use_defaults:
            self._check_truncate_policy(secret)
        return des_crypt(salt=self.salt[:2])._calc_checksum(secret)


class django_disabled(uh.ifc.DisabledHash, uh.StaticHandler):
    name = 'django_disabled'
    _hash_prefix = u('!')
    suffix_length = 40

    @classmethod
    def identify(cls, hash):
        hash = uh.to_unicode_for_identify(hash)
        return hash.startswith(cls._hash_prefix)

    def _calc_checksum(self, secret):
        return getrandstr(rng, BASE64_CHARS[:-2], self.suffix_length)

    @classmethod
    def verify(cls, secret, hash):
        uh.validate_secret(secret)
        if not cls.identify(hash):
            raise uh.exc.InvalidHashError(cls)
        return False